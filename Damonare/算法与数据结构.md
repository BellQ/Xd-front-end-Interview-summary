1. 输入两个链表，分别代表两个数字的倒序排列如下：
   342+465 = 807;
> Input: (2 -> 4 -> 3) + (5 -> 6 -> 4)
> Output: 7 -> 0 -> 8

```javascript
/**
 * ListNode类用来生成具体的节点
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
var addTwoNumbers = function(l1, l2) {
    var l = new ListNode(0);
    var head = l;
    var sum = 0;
    var front = 0;
    // sum === 1 是用来满足特殊情况
    while (l1 !== null || l2 !== null || sum === 1) {
        if (l1) {
            sum += l1.val;
            l1 = l1.next;
        }
        if (l2) {
            sum += l2.val;
            l2 = l2.next;
        }
        if (sum >= 10) {
            front = 1;
            sum -= 10;
        }
        head.next = new ListNode(sum);
        head = head.next;
        sum = front;
        front = 0;
    }
    return l.next;
};
```
2. 给定数组和固定的数，返回数组中元素和为该数的下标

> 比如： nums = [2, 7, 11, 15], target = 9,
> 因为 nums[0] + nums[1] = 2 + 7 = 9,
> return [0, 1].

```javascript
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
var twoSum = function(nums, target) {
    // 时间复杂度较高，mark修改
    for (var i = 0; i < nums.length; i++) {
        for (var j = i + 1; j < nums.length; j++) {
            if (nums[i] + nums[j] === target) {
                return [i, j];
            }
        }
    }
};
```
3. Hamming距离，示例如下：
> Input: x = 1, y = 4
> Output: 2
> Explanation:
> 1   (0 0 0 1)
> 4   (0 1 0 0)

```javascript
/**
 * @param {number} x
 * @param {number} y
 * @return {number}
 */
var hammingDistance = function(x, y) {
    // 位运算之美
    if (x < 0 || y < 0) {
        return false;
    }
    var xor = x ^ y;
    var dis = 0;
    while (xor) {
        // 此处的判断是点睛之笔 1，0的转换很巧妙吧2333
        if ((xor >> 1) << 1 !== xor) {
            dis += 1;
        }
        xor = xor >> 1;
    }
    return dis;
};
```
4. 给定偶数数目的数组，分组为(a1, b1), (a2, b2), ..., (an, bn) 然后求所有 min(ai, bi) 和的最大值
> Input: [1,4,3,2]
> Output: 4

```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var arrayPairSum = function(nums) {
    // 首先进行排序，所谓和的最大值自然就容易计算了
    var arr = nums.sort(function(a, b){return a - b;});
    var sum = 0;
    for (var i = 0; i < nums.length/2; i++) {
        sum += arr[2*i];
    }
    return sum;
};
```
5. 给定一个正整数，求它的补位，比如：
>Input: 5
>Output: 2
>Explanation: 例如5的二进制是101(不包括0位), 它的补位为010,所以你需要输出2.

```javascript
/**
 * @param {number} num
 * @return {number}
 */
var findComplement = function(num) {
    // 使用进制的转换容易的多
    var bin = num.toString(2).split('');
    console.log(bin)
    for (var i = 0; i < bin.length; i++) {
        bin[i] = bin[i] === '0' ? '1' : '0';
    }
    return parseInt(bin.join(''), 2);
};
```
6. 给定字符串，求最长元素不重复的子字符串
> Given "abcabcbb", the answer is "abc", which the length is 3.
>
> Given "bbbbb", the answer is "b", with the length of 1.

```javascript
/**
 * @param {string} s
 * @return {number}
 */
var lengthOfLongestSubstring = function(s) {
    var arr = s.split('');
    var temp = [];
    var len = 0;
    // 时间复杂度待优化
    while (arr.length >= 1) {
        for (var i = 0; i < arr.length; i++) {
            if (temp.indexOf(arr[i]) === -1) {
                temp.push(arr[i]);
            } else {
                break;
            }
        }
        arr.shift();
        len = temp.length > len ? temp.length : len;
        temp = [];
    }
    return len;
};
```
7. 给定一个数字数组，该数组只包含一个只出现一次的元素，输出这个只出现一次的数字
> Input: [1,1,2,3,3,4,4,8,8]
> Output: 2

```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var singleNonDuplicate = function(nums) {
    // 经典位运算问题，之前看过一篇位运算之美的博客，正好有讲到，JavaScript的函数式编程太美
    return nums.reduce(function(sum, value) {
        return sum ^ value;
    })  
};
```
8. 给定数字数组，找到所有满足a+b+c=0的元素返回；

```
输入：[-1, 0, 1, 2, -1, -4],
输出：
[
  [-1, 0, 1],
  [-1, -1, 2]
]
```

```javascript
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
 // 此题借鉴了别人的答案
var threeSum = function(nums) {
   var arr = [];
   nums = nums.sort(function(a, b) { return a - b; });
   if (nums.length < 3 || nums[0] > 0) {
   	    return arr;
   }
   for (var i = 0; i < nums.length; i++) {
   		if (nums[i] === nums[i-1]) {
   			continue;
   		}
   		var start = i + 1, end = nums.length - 1;
   		while (start < end) {
   			var sum = nums[i] + nums[start] + nums[end];
   			if (sum === 0) {
   				arr.push([nums[i], nums[start], nums[end]]);
   				start += 1;
   				end -= 1;
                // 借鉴的核心在这两句代码，排除重复的数组
   				while (start < end && nums[start] === nums[start-1]) { start += 1}
   				while (start < end && nums[end] === nums[end+1]) { end -= 1}
   			} else if (sum < 0) {
   				start += 1;
   			} else {
   				end -= 1;
   			}
   		}
   }
   return arr;
};
```
9. 翻转数字

> Example1: x = 123, return 321
>
> Example2: x = -123, return -321

```javascript  
/**
 * @param {number} x
 * @return {number}
 */
var reverse = function(x) {
    // 纯粹API运用
    var result = parseInt(x.toString().split('').reverse().join(''));
	return x > 0
	? result > Math.pow(2, 31)
		? 0
		: result
	: result > Math.pow(2, 31)
		? 0
		: -result;
};
```
10. 输入两个链表，分别代表两个数字的倒序排列如下：
7243 + 564 = 7807;
>Input: (7 -> 2 -> 4 -> 3) + (5 -> 6 -> 4)
>Output: 7 -> 8 -> 0 -> 7

```javascript
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
// 解决思路: 链表和栈的转换
var addTwoNumbers = function(l1, l2) {
    var s1 = [], s2 = [], s = [];
    var l = new ListNode(0);
    var head = l;
    var sum = 0, front = 0;
    // 利用数组将链表l1,l2转化为栈s1,s2来解决,结果输出到栈s,再出栈输入链表l
    while (l1 !== null) {
        s1.unshift(l1.val);
        l1 = l1.next;
    }
    while (l2 !== null) {
        s2.unshift(l2.val);
        l2 = l2.next;
    }
    while (s1.length > 0 || s2.length > 0 || sum > 0) {
        console.log(s1, s2);
        if (s1.length > 0) {
            sum += s1.shift();
        }
        if (s2.length > 0) {
            sum += s2.shift();
        }
        if (sum >= 10) {
            sum -= 10;
            front = 1;
        }
        s.unshift(sum);
        sum = front;
        front = 0;
    }
    while (s.length > 0) {
        head.next = new ListNode(s.shift());
        head = head.next;
    }
    return l.next;
};
```
11. 回文数字的判断

> 比如:121是回文数

```javascript
/**
 * @param {number} x
 * @return {boolean}
 */
var isPalindrome = function(x) {
    return x === parseInt(x.toString().split('').reverse().join('')) ? true : false;
};
```
12. 树转字符串

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} t
 * @return {string}
 */
var tree2str = function(t) {
    if (!t) return '';
    // 借鉴了网友的写法
    var left = tree2str(t.left);
    var right = tree2str(t.right);
    return t.val + (left || right ? '(' + left + ")" : '') + (right ? '(' + right + ')' : '');
 };

```
13. 翻转二叉树

> 来自网友的答案

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {TreeNode}
 */
 // 借鉴了网友答案
function invertTree(root) {
    if (root) {
        [root.left, root.right] = [invertTree(root.right), invertTree(root.left)]
    }
    return root;
}
```
14. 相同二叉树判断

> 感觉用了太多判断...出口太多...

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} p
 * @param {TreeNode} q
 * @return {boolean}
 */
var isSameTree = function(p, q) {
    if (p && q && p.val === q.val) {
        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);
    }
    // 此处略复杂，但是是满足所有case的写法
    if ((p && q && p.val !== q.val) || (!p && q) || (p && !q)) {
        return false;
    }
    if (!p && !q) {
        return true;
    }
};
```
15. 根据前序遍历和中序遍历推导二叉树

> 核心是这个递归思路

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {number[]} inorder
 * @param {number[]} postorder
 * @return {TreeNode}
 */
var buildTree = function(inorder, postorder) {
    if (inorder.length === 1) {
        return new TreeNode(inorder[0]);
    }
    if (inorder.length === 0) {
        return null;
    }
    var value = postorder[postorder.length - 1];
    var root = new TreeNode(value);
    var index = inorder.indexOf(value);
    root.left = buildTree(inorder.slice(0, index), postorder.slice(0, index));
    root.right = buildTree(inorder.slice(index + 1, inorder.length), postorder.slice(index, postorder.length-1));
    return root;
};
```
16. 已知前序排列和中序排列推导二叉树

> 只是对前面的结果更改参数和具体截断的位置罢了...

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {number[]} preorder
 * @param {number[]} inorder
 * @return {TreeNode}
 */
var buildTree = function(preorder, inorder) {
    if (inorder.length === 1) {
        return new TreeNode(inorder[0]);
    }
    if (inorder.length === 0) {
        return null;
    }
    var value = preorder[0];
    var root = new TreeNode(value);
    var index = inorder.indexOf(value);
    root.left = buildTree(preorder.slice(1, index + 1), inorder.slice(0, index));
    root.right = buildTree(preorder.slice(index + 1, preorder.length), inorder.slice(index + 1, inorder.length));
    return root;
};
```
17. 判断一个链表是否是回文的

遍历链表，储存在栈中，通过对栈的数据进行判断

```javascript
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} head
 * @return {boolean}
 */
var isPalindrome = function(head) {
    var arr = [];
    while (head) {
        arr.push(head.val);
        head = head.next;
    }
    for (var i = 0, j = arr.length - 1; i <= j;) {
        if (arr[i] !== arr[j]) {
            return false;
        } else {
            j -= 1;
            i += 1
        }
    }
    return true;
};
```
18. 反转链表


> 借助栈来解决很简单


```javascript
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var reverseList = function(head) {
    var stack = [],
        newList = new ListNode(0),
        temp = newList;
    while (head) {
        stack.push(head.val);
        head = head.next;
    }
    while (stack.length > 0) {
        temp.next = new ListNode(stack.pop());
        temp = temp.next;
    }
    return newList.next;
};
```
19. 从链表中移除制定元素

> 改变下指针的指向即可

```javascript  
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} head
 * @param {number} val
 * @return {ListNode}
 */
var removeElements = function(head, val) {
    // 链表为空返回Null
    if (head === null) return null;
    var temp = head;
    while (temp.next !== null) {
        if (temp.next.val === val) {
            temp.next = temp.next.next;
            continue;
        }
        temp = temp.next;
    }
    // 对单元素链表进行特殊处理
    return head.val === val ? head.next : head;
};
```
20. 反转字符串(2)

> 指定位置反转，比如：Given 1->2->3->4->5->NULL, m = 2 and n = 4,
return 1->4->3->2->5->NULL.

```javascript
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} head
 * @param {number} m
 * @param {number} n
 * @return {ListNode}
 */
 // 借用了栈，似乎没法通过直接改变指针来做
var reverseBetween = function(head, m, n) {
    if (m > n) {
        return head;
    }
    var stack = [], temp = [];
    while (head) {
        stack.push(head.val);
        head = head.next;
    }
    console.log(stack);
    if (m !== n) {
        temp = stack.splice(m - 1, n - m + 1).reverse();
    }
    for (var i = 0; i < temp.length; i++) {
        stack.splice(m - 1 + i, 0, temp[i]);
    }
    console.log(temp);
    var newList = new ListNode(0);
    var replace = newList;
    while (stack.length > 0) {
        replace.next = new ListNode(stack.shift());
        replace = replace.next;
    }
    return newList.next;
};
```
21. 链表去重(已排序)

> Given 1->1->2, return 1->2.
Given 1->1->2->3->3, return 1->2->3.

```javascript
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
// 借用了栈，转化为了数组去重，但感觉如果使用递归时间复杂度会更低
var deleteDuplicates = function(head) {
    var stack = [];
    while (head) {
        stack.push(head.val);
        head = head.next;
    }
    console.log(stack)
    stack = Array.from(new Set(stack));
    console.log(stack)
    var newList = new ListNode(0);
    var temp = newList;
    while (stack.length > 0) {
        temp.next = new ListNode(stack.shift());
        temp = temp.next;
    }
    return newList.next;
};
```
22. 从结尾算起删除链表第n个元素

>  Given linked list: 1->2->3->4->5, and n = 2.
After removing the second node from the end, the linked list becomes 1->2->3->5.

```javascript
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} head
 * @param {number} n
 * @return {ListNode}
 */
 // 依然借用栈解决...
var removeNthFromEnd = function(head, n) {
    var stack = [];
    while (head) {
        stack.push(head.val);
        head = head.next;
    }
    console.log(stack);
    stack.splice(-n, 1);
    console.log(stack);
    var result = new ListNode(0);
    var temp = result;
    while (stack.length > 0) {
        temp.next = new ListNode(stack.shift());
        temp = temp.next;
    }
    return result.next;
};
```
23. 去除数组重复元素

> Given input array nums = [1,1,2],
Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively. It doesn't matter what you leave beyond the new length.

```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
// 借鉴了网友Java实现的答案,主要没弄懂它的返回值具体要求，有点迷。
var removeDuplicates = function(nums) {
    if (nums.length === 0) return 0;
    var j = 0;
    for (var i = 0; i < nums.length; i++)
        if (nums[i] !== nums[j]) nums[++j] = nums[i];
    return ++j;
};
```
24. 反转句子中的每个单词

> Input: "Let's take LeetCode contest"
Output: "s'teL ekat edoCteeL tsetnoc"

```javascript
/**
 * @param {string} s
 * @return {string}
 */
var reverseWords = function(s) {
    var arr = s.split(' ' );
    for (var i = 0; i < arr.length; i++) {
        arr[i] = arr[i].split('').reverse().join('');
    }
    return arr.join(' ');
};
```
25. 分配糖果问题，输入一个数字数组(长度固定位偶数)，每一个数字代表一种糖果，将这些糖果分配给两个孩子，求孩子能得到的最大的糖果种类数。
> Input: candies = [1,1,2,2,3,3]
Output: 3
Explanation:
这有不同的糖果(1, 2 and 3), 然后每个孩子三个不同的糖果

```javascript
/**
 * @param {number[]} candies
 * @return {number}
 */
// 刚开始想的是在排序之后的基础上对半分，发现一些case无法满足，然后想奇偶分。一些case还是没法满足
// 后来醒悟，实际上这是个简单的数组去重的题目
var distributeCandies = function(candies) {
    if (candies > 10000 || candies < 2 || candies.length % 2 !== 0) {
        return false;
    }
    var temp = Array.from(new Set(candies));
    console.log(temp);
    return temp.length <= candies.length / 2
        ? temp.length
        : candies.length / 2
};
```
26. 反转字符串

> Given s = "hello", return "olleh".

[Reverse String](https://leetcode.com/problems/reverse-string/#/description)

```javascript
/**
 * @param {string} s
 * @return {string}
 */
// 这算是偷懒的写法么...再次充当API搬运工的角色
var reverseString = function(s) {
    return s.split('').reverse().join('');
};
```
27. 给定两个数组num1和num2，已知num1是num2的子集，求num1的元素在num2数组中位置之后的第一个比该元素大的集合(如果没有则返回-1)。

> Input: nums1 = [4,1,2], nums2 = [1,3,4,2].
Output: [-1,3,-1]
Explanation:
    For number 4 in the first array, you cannot find the next greater number for it in the second array, so output -1.
    For number 1 in the first array, the next greater number for it in the second array is 3.
    For number 2 in the first array, there is no next greater number for it in the second array, so output -1.

[ Next Greater Element I](https://leetcode.com/problems/next-greater-element-i/#/description)

```javascript
/**
 * @param {number[]} findNums
 * @param {number[]} nums
 * @return {number[]}
 */
var nextGreaterElement = function(findNums, nums) {
    var result = [];
    for (var i = 0; i < findNums.length; i++) {
        var temp = nums.indexOf(findNums[i]);
        var j = temp + 1;
        while (j < nums.length) {
            if (nums[temp] < nums[j]) {
                result.push(nums[j]);
                break;
            } else {
                j += 1;
            }
        }
        if (j === nums.length) {
            result.push(-1);
        }
    }
    return result;
};
```
28. 寻找数组中最大连续1的数目：给定二进制数组(元素只包括0,1)

> Input: [1,1,0,1,1,1]
Output: 3
Explanation: The first two digits or the last three digits are consecutive 1s.
    The maximum number of consecutive 1s is 3.

```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
 // 没仔细看题目，刚开始以为是找最长连续数字，白白浪费了时间...
var findMaxConsecutiveOnes = function(nums) {
    var temp = 0,
        len = 0;
    for (var i = 0; i < nums.length; i++) {
        if (nums[i]) {
            temp += 1;
            len = len > temp ? len : temp;
        } else {
            temp = 0;
        }
    }
    return len;
};
```
29. 查找单数:给定数组，元素内部只有一个数字出现一次，其它都是出现两次，找出这个只出现一次的数字

> 和7题重复了

[Single Number](https://leetcode.com/problems/single-number/#/description)

```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var singleNumber = function(nums) {
    return nums.reduce(function(a,b) {
        return a ^ b;
    })
};
```
30. 最长单独序列：给定两个字符串，判断两个有没有父子集关系

> Input: "aba", "cdc"
Output: 3
Explanation: The longest uncommon subsequence is "aba" (or "cdc"),
because "aba" is a subsequence of "aba",
but not a subsequence of any other strings in the group of two strings.

[Longest Uncommon Subsequence I](https://leetcode.com/problems/longest-uncommon-subsequence-i/#/description)

```javascript
/**
 * @param {string} a
 * @param {string} b
 * @return {number}
 */
 // 主要是一些逻辑判断
var findLUSlength = function(a, b) {
    var len = -1;
    if (a.indexOf(b) === -1 && b.indexOf(a) === -1) {
        len = a.length >= b.length ? a.length : b.length;
    } else if (a.indexOf(b) !== -1 && b.indexOf(a) === -1) {
        len = a.length;
    } else if (b.indexOf(a) !== -1 && a.indexOf(b) === -1) {
        len =  b.length;
    } else {
        len = -1;
    }
    return len;
};
```
31. 侦查字符串：
> 如下情况返回true:
所有字母大写 ex:"USA".
所有字母小写 ex:"leetcode".
第一个字母大写，其余小写 ex:"Google".

[Detect Capital](https://leetcode.com/problems/detect-capital/#/description)

```javascript
/**
 * @param {string} word
 * @return {boolean}
 */
 // 使用正则很简单就解决，遇到一个问题：正则表达式对象字面量没法使用变量
var detectCapitalUse = function(word) {
    var len = word.length;
    var par = new RegExp(`[A-Z]{${len}}|[a-z]{${len}}|[A-Z][a-z]{${len-1}}`,'g');
    return par.test(word);
};
```
32. 寻找缺失的数字:给定数组1 ≤ a[i] ≤ n (n = size of array)，寻找缺失的数字

> Input:
[4,3,2,7,8,2,3,1]
Output:
[5,6]

[Find All Numbers Disappeared in an Array](https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/#/description)

```javascript
/**
 * @param {number[]} nums
 * @return {number[]}
 */
var findDisappearedNumbers = function(nums) {
    var result = [];
    for (var i = 0; i < nums.length; i++) {
        var index = Math.abs(nums[i]) - 1;
        if (nums[index] > 0) {
            nums[index] = -nums[index];
        }
    }
    console.log(nums);
    for (var j = 0; j < nums.length; j++) {
        if (nums[j] > 0) {
            result.push(j + 1);
        }
    }

    return result;
};
```
